<#import "../macro/constraints.ftl" as CONSTRAINTS>
<#assign with_clause = false>
<#if fillfactor!false || parallel_workers!false || toast_tuple_target!false || (autovacuum_custom!false && add_vacuum_settings_in_sql!false) || autovacuum_enabled != 't' || autovacuum_enabled != 'f' || (toast_autovacuum!false && add_vacuum_settings_in_sql!false) || toast_autovacuum_enabled != 't' || toast_autovacuum_enabled!= 'f' >
    <#assign with_clause = true>
</#if>
CREATE <#if relpersistence!false >UNLOGGED </#if>TABLE IF NOT EXISTS ${schema}. ${name}
<#if typname?? >
OF ${typname }
</#if>
<#if like_relation?? || coll_inherits!false || columns?size gt 0 || primary_key?size gt 0 || unique_constraint?size gt 0 || foreign_key?size gt 0 || check_constraint?size gt 0 || exclude_constraint?size gt 0 >
(
</#if>
<#if like_relation?? >
LIKE ${like_relation }<#if like_default_value!false >

        INCLUDING DEFAULTS</#if><#if like_constraints!false >

        INCLUDING CONSTRAINTS</#if><#if like_indexes!false >

        INCLUDING INDEXES</#if><#if like_storage!false >

        INCLUDING STORAGE</#if><#if  like_comments!false >

        INCLUDING COMMENTS</#if><#if  columns?size gt 0 >,
</#if>

</#if>
<#if columns?? && columns?size gt 0 >
<#list columns as c >
<#if c.name?? && c.cltype?? >
<#if c.inheritedfromtable?? >-- Inherited from table ${c.inheritedfromtable}: <#elseif c.inheritedfromtype?? >-- Inherited from type ${c.inheritedfromtype}: </#if>${c.name} ${c.displaytypname}<#if c.collspcname?? && c.collspcname?length gt 0 > COLLATE ${c.collspcname}</#if><#if c.attnotnull!false > NOT NULL</#if><#if c.defval?? && c.defval != '' && c.colconstype?? && c.colconstype != 'g' > DEFAULT ${c.defval}</#if>
<#if c.colconstype?? && c.colconstype == 'i' && c.attidentity?? && c.attidentity != '' >
<#if c.attidentity?? &&  c.attidentity == 'a' > GENERATED ALWAYS AS IDENTITY<#elseif c.attidentity?? && c.attidentity == 'd' > GENERATED BY DEFAULT AS IDENTITY</#if>
<#if c.seqincrement?? || c.seqcycle!false || c.seqincrement?? || c.seqstart?? || c.seqmin?? || c.seqmax?? || c.seqcache?? > ( </#if>
<#if c.seqcycle!false >
CYCLE </#if><#if c.seqincrement?? && c.seqincrement?number gt -1 >
INCREMENT ${c.seqincrement} </#if><#if c.seqstart?? && c.seqstart?number gt -1>
START ${c.seqstart} </#if><#if c.seqmin?? && c.seqmin?number gt -1>
MINVALUE ${c.seqmin} </#if><#if c.seqmax?? && c.seqmax?number gt -1>
MAXVALUE ${c.seqmax} </#if><#if c.seqcache?? && c.seqcache?number gt -1>
CACHE ${c.seqcache} </#if>
<#if c.seqincrement?? || c.seqcycle!false || c.seqincrement?? || c.seqstart?? || c.seqmin?? || c.seqmax?? || c.seqcache?? >)</#if>
</#if>
<#if c.colconstype?? && c.colconstype == 'g' && c.genexpr?? && c.genexpr != '' > GENERATED ALWAYS AS (${c.genexpr}) STORED</#if>
<#if c?counter lt columns?size>,
</#if>
</#if>
</#list>
</#if>
<#if primary_key?size gt 0 ><#if columns?size gt 0 >,</#if>
<@CONSTRAINTS.PRIMARY_KEY /></#if><#if unique_constraint?size gt 0 ><#if columns?size gt 0 || primary_key?size gt 0 >,</#if>
<@CONSTRAINTS.UNIQUE /></#if><#if foreign_key?size gt 0 ><#if columns?size gt 0 || primary_key?size gt 0 || unique_constraint?size gt 0 >,</#if>
<@CONSTRAINTS.FOREIGN_KEY /></#if><#if check_constraint?size gt 0 ><#if columns?size gt 0 || primary_key?size gt 0 || unique_constraint?size gt 0 || foreign_key?size gt 0 >,</#if>
<@CONSTRAINTS.CHECK/></#if><#if exclude_constraint?size gt 0 ><#if columns?size gt 0 || primary_key?size gt 0 || unique_constraint?size gt 0 || foreign_key?size gt 0 || check_constraint?size gt 0 >,</#if>
<@CONSTRAINTS.EXCLUDE/></#if>
<#if like_relation?? || coll_inherits!false || columns?size gt 0 || primary_key?size gt 0 || unique_constraint?size gt 0 || foreign_key?size gt 0 || check_constraint?size gt 0 || exclude_constraint?size gt 0 >

)</#if><#if relkind?? && relkind == 'p' > PARTITION BY ${ partition_scheme }</#if>
<#if !(coll_inherits??) && !(spcname??) && !with_clause >;</#if>

<#if coll_inherits?? && coll_inherits?size > 0>
INHERITS (<#list coll_inherits as val ><#if val?counter != 1 >, </#if>${val}</#list>)<#if !(spcname??) && !with_clause >;</#if>
</#if>

<#if with_clause >
<#assign add_comma=false>
WITH (
<#if fillfactor?? ><#assign add_comma=true>
FILLFACTOR = ${ fillfactor }</#if><#if parallel_workers?? >
<#if add_comma >,
</#if>
parallel_workers = ${ parallel_workers }<#assign add_comma=true></#if><#if toast_tuple_target?? >
<#if add_comma >,
</#if>
toast_tuple_target = ${ toast_tuple_target }<#assign add_comma=true></#if><#if autovacuum_enabled?? && (autovacuum_enabled == 't' || autovacuum_enabled == 'f') >
<#if add_comma >,
</#if>
autovacuum_enabled = <#if autovacuum_enabled == 't' >TRUE<#else >FALSE</#if><#assign add_comma=true></#if><#if toast_autovacuum_enabled?? && (toast_autovacuum_enabled == 't' || toast_autovacuum_enabled == 'f')  >
<#if add_comma >,
</#if>
toast.autovacuum_enabled = <#if toast_autovacuum_enabled == 't' >TRUE<#else >FALSE</#if><#assign add_comma=true></#if><#if autovacuum_custom >
{% for opt in vacuum_table ><#if opt.name and opt.value is defined >
<#if add_comma >,
</#if>
${opt.name} = ${opt.value}<#assign add_comma=true></#if>
{% endfor ></#if><#if toast_autovacuum >
{% for opt in vacuum_toast ><#if opt.name and opt.value is defined >
<#if add_comma >,
</#if>
toast.${opt.name} = ${opt.value}<#assign add_comma=true></#if>
{% endfor ></#if>

<#if spcname >){% else >);</#if>

</#if>
{### SQL for Tablespace ###}
<#if spcname >
TABLESPACE ${ conn|qtIdent(spcname) };
</#if>
{### Alter SQL for Owner ###}
<#if relowner >

ALTER TABLE IF EXISTS ${conn|qtIdent(schema, name)}
OWNER to ${conn|qtIdent(relowner)};
</#if>

{#####################################################}
{## Enable Row Level Security Policy on table ##}
{#####################################################}
<#if rlspolicy >
ALTER TABLE IF EXISTS ${conn|qtIdent(schema, name)}
ENABLE ROW LEVEL SECURITY;
</#if>

{#####################################################}
{## Force Enable Row Level Security Policy on table ##}
{#####################################################}
<#if forcerlspolicy >
ALTER TABLE IF EXISTS ${conn|qtIdent(schema, name)}
FORCE ROW LEVEL SECURITY;
</#if>

{### Security Labels on Table ###}
<#if seclabels and seclabels?size gt 0 >

{% for r in seclabels >
${ SECLABEL.SET(conn, 'TABLE', name, r.provider, r.label, schema) }
{% endfor >
</#if>
{###  ACL on Table ###}
<#if revoke_all >
{% for priv in revoke_all >
${ PRIVILEGE.UNSETALL(conn, "TABLE", priv, name, schema)}
{% endfor >
</#if>
<#if relacl >

{% for priv in relacl >
${ PRIVILEGE.SET(conn, 'TABLE', priv.grantee, name, priv.without_grant, priv.with_grant, schema) }
{% endfor >
</#if>
{### SQL for COMMENT ###}
<#if description >
COMMENT ON TABLE ${conn|qtIdent(schema, name)}
IS ${description|qtLiteral};
</#if>
{#===========================================#}
{#====== MAIN TABLE TEMPLATE ENDS HERE ======#}
{#===========================================#}
{#===========================================#}
{#  COLUMN SPECIFIC TEMPLATES STARTS HERE    #}
{#===========================================#}
<#if columns and columns?size gt 0 >
{% for c in columns >
<#if c.description >

COMMENT ON COLUMN ${conn|qtIdent(schema, name, c.name)}
IS ${c.description|qtLiteral};
</#if>
{###  Add variables to column ###}
<#if c.attoptions and c.attoptions?size gt 0 >

ALTER TABLE IF EXISTS ${conn|qtIdent(schema, name)}
${ VARIABLE.SET(conn, 'COLUMN', c.name, c.attoptions) }

</#if>
{###  Alter column statistics value ###}
<#if c.attstattarget is defined and c.attstattarget > -1 >
ALTER TABLE IF EXISTS ${conn|qtIdent(schema, name)}
ALTER COLUMN ${conn|qtTypeIdent(c.name)} SET STATISTICS ${c.attstattarget};

</#if>
{###  Alter column storage value ###}
<#if c.attstorage is defined and c.attstorage != c.defaultstorage >
ALTER TABLE IF EXISTS ${conn|qtIdent(schema, name)}
ALTER COLUMN ${conn|qtTypeIdent(c.name)} SET STORAGE {%if c.attstorage == 'p' >
PLAIN{% elif c.attstorage == 'm'>MAIN{% elif c.attstorage == 'e'>
EXTERNAL{% elif c.attstorage == 'x'>EXTENDED</#if>;

</#if>
{###  ACL ###}
<#if c.attacl and c.attacl?size gt 0 >

{% for priv in c.attacl >
${ COLUMN_PRIVILEGE.APPLY(conn, schema, name, c.name, priv.grantee, priv.without_grant, priv.with_grant) }
{% endfor >
</#if>
{###  Security Lables ###}
<#if c.seclabels and c.seclabels?size gt 0 >

{% for r in c.seclabels >
${ COLUMN_SECLABEL.APPLY(conn, 'COLUMN',schema, name, c.name, r.provider, r.label) }
{% endfor >
</#if>
{% endfor >
</#if>
{#===========================================#}
{#   COLUMN SPECIFIC TEMPLATES ENDS HERE     #}
{#===========================================#}
{#======================================#}
{#   CONSTRAINTS SPECIFIC TEMPLATES     #}
{#======================================#}
${CONSTRAINTS.CONSTRAINT_COMMENTS(conn, schema, name, primary_key)}
${CONSTRAINTS.CONSTRAINT_COMMENTS(conn, schema, name, unique_constraint)}
${CONSTRAINTS.CONSTRAINT_COMMENTS(conn, schema, name, foreign_key)}
${CONSTRAINTS.CONSTRAINT_COMMENTS(conn, schema, name, check_constraint)}
${CONSTRAINTS.CONSTRAINT_COMMENTS(conn, schema, name, exclude_constraint)}
