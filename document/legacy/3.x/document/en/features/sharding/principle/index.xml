<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Guide to Kernel on ShardingSphere</title>
    <link>https://shardingsphere.apache.org/document/legacy/3.x/document/en/features/sharding/principle/</link>
    <description>Recent content in Guide to Kernel on ShardingSphere</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="https://shardingsphere.apache.org/document/legacy/3.x/document/en/features/sharding/principle/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Parse Engine</title>
      <link>https://shardingsphere.apache.org/document/legacy/3.x/document/en/features/sharding/principle/parse/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/legacy/3.x/document/en/features/sharding/principle/parse/</guid>
      <description>SQL is relatively simple compared to other programming languages, but it is still a complete set of programming language, so there is no essential difference between parsing SQL grammar and parsing other languages (Java, C and Go, etc.).
Abstract Syntax Tree The parsing process can be divided into lexical parsing and syntactic parsing. Lexical parser is used to divide SQL into indivisible atomic signs, i.e., Token. According to the dictionary provided by different database dialect, it is categorized into keyword, expression, literal and operator.</description>
    </item>
    
    <item>
      <title>Route Engine</title>
      <link>https://shardingsphere.apache.org/document/legacy/3.x/document/en/features/sharding/principle/route/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/legacy/3.x/document/en/features/sharding/principle/route/</guid>
      <description>It is the sharding strategy that matches databases and tables according to the parsing context and generates route path. SQL with sharding keys can be divided into single-sharding route (equal mark as the operator of sharding key), multiple-sharding route (IN as the operator of sharding key) and range sharding route (BETWEEN as the operator of sharding key). SQL without sharding key adopts broadcast route.
Sharding strategies can usually be set in the database or by users.</description>
    </item>
    
    <item>
      <title>Rewrite Engine</title>
      <link>https://shardingsphere.apache.org/document/legacy/3.x/document/en/features/sharding/principle/rewrite/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/legacy/3.x/document/en/features/sharding/principle/rewrite/</guid>
      <description>The SQL written by developers facing logic databases and logic tables cannot be executed directly in actual databases. The SQL rewrite is used to rewrite logic SQL into the rightly executable one in actual databases, including two parts, correctness rewrite and optimization rewrite.
Correctness Rewrite In the situation that contains sharding tables, it requires to rewrite logic table names in sharding settings into actual table names acquired after routing. Database sharding does not require the rewrite of table names.</description>
    </item>
    
    <item>
      <title>Execute Engine</title>
      <link>https://shardingsphere.apache.org/document/legacy/3.x/document/en/features/sharding/principle/execute/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/legacy/3.x/document/en/features/sharding/principle/execute/</guid>
      <description>ShardingSphere adopts a set of automatic execution engine, responsible for sending the true SQL, which has been routed and rewritten, to execute in the underlying data source safely and effectively. It does not directly send the SQL through JDBC to execute in the underlying data source simply, or put execution requests directly to the thread pool to execute concurrently, but focuses more on the creation of a balanced data source connection, the consumption generated by the memory usage, the maximum utilization of the concurrency and other problems.</description>
    </item>
    
    <item>
      <title>Merger Engine</title>
      <link>https://shardingsphere.apache.org/document/legacy/3.x/document/en/features/sharding/principle/merge/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/document/legacy/3.x/document/en/features/sharding/principle/merge/</guid>
      <description>Result merger refers to merging multi-data result set acquired from all the data nodes as one result set and returning it to the request end rightly.
In function, the result merger supported by ShardingSphere can be divided into iteration, order-by, group-by, pagination and aggregation these five kinds, which are in composition relation rather than clash relation. In structure, it can be divided into stream merger, memory merger and decorator merger, in which stream merger and the memory merger clash with each other, and the decorator merger can be further processed based on stream merger and memory merger.</description>
    </item>
    
  </channel>
</rss>