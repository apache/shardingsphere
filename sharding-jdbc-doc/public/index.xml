<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sharding-JDBC</title>
    <link>http://dangdangdotcom.github.io/sharding-jdbc/</link>
    <description>Recent content on Sharding-JDBC</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://dangdangdotcom.github.io/sharding-jdbc/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title></title>
      <link>http://dangdangdotcom.github.io/sharding-jdbc/index/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://dangdangdotcom.github.io/sharding-jdbc/index/</guid>
      <description>

&lt;h1 id=&#34;主要贡献者:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;主要贡献者&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;张亮 &amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=&#34;http://www.dangdang.com/&#34;&gt;当当&lt;/a&gt; zhangliang@dangdang.com&lt;/li&gt;
&lt;li&gt;高洪涛 &lt;a href=&#34;http://www.dangdang.com/&#34;&gt;当当&lt;/a&gt; gaohongtao@dangdang.com&lt;/li&gt;
&lt;li&gt;曹昊 &amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=&#34;http://www.dangdang.com/&#34;&gt;当当&lt;/a&gt; caohao@dangdang.com&lt;/li&gt;
&lt;li&gt;岳令 &amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=&#34;http://www.dangdang.com/&#34;&gt;当当&lt;/a&gt; yueling@dangdang.com&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;讨论QQ群：&lt;/strong&gt;532576663（不限于Sharding-JDBC，包括分布式，数据库相关以及其他互联网技术交流）&lt;/p&gt;

&lt;h1 id=&#34;简介:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;简介&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;Sharding-JDBC&lt;/code&gt;是当当应用框架&lt;code&gt;ddframe&lt;/code&gt;中，关系型数据库模块&lt;code&gt;dd-rdb&lt;/code&gt;中分离出来的数据库水平扩展框架，即透明化数据库分库分表访问。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Sharding-JDBC&lt;/code&gt;直接封装&lt;code&gt;JDBC API&lt;/code&gt;，可以理解为增强版的&lt;code&gt;JDBC&lt;/code&gt;驱动，旧代码迁移成本几乎为零：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;可适用于任何基于&lt;code&gt;java&lt;/code&gt;的&lt;code&gt;ORM&lt;/code&gt;框架，如：&lt;code&gt;JPA&lt;/code&gt;, &lt;code&gt;Hibernate&lt;/code&gt;, &lt;code&gt;Mybatis&lt;/code&gt;, &lt;code&gt;Spring JDBC Template&lt;/code&gt;或直接使用&lt;code&gt;JDBC&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;可基于任何第三方的数据库连接池，如：&lt;code&gt;DBCP&lt;/code&gt;, &lt;code&gt;C3P0&lt;/code&gt;, &lt;code&gt;BoneCP&lt;/code&gt;, &lt;code&gt;Druid&lt;/code&gt;等。&lt;/li&gt;
&lt;li&gt;理论上可支持任意实现&lt;code&gt;JDBC&lt;/code&gt;规范的数据库。虽然目前仅支持&lt;code&gt;MySQL&lt;/code&gt;，但已有支持&lt;code&gt;Oracle&lt;/code&gt;，&lt;code&gt;SQLServer&lt;/code&gt;，&lt;code&gt;DB2&lt;/code&gt;等数据库的计划。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;Sharding-JDBC&lt;/code&gt;定位为轻量级&lt;code&gt;java&lt;/code&gt;框架，使用客户端直连数据库，以&lt;code&gt;jar&lt;/code&gt;包形式提供服务，未使用中间层，无需额外部署，无其他依赖，&lt;code&gt;DBA&lt;/code&gt;也无需改变原有的运维方式。&lt;code&gt;SQL&lt;/code&gt;解析使用&lt;code&gt;Druid&lt;/code&gt;解析器，是目前性能最高的&lt;code&gt;SQL&lt;/code&gt;解析器。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Sharding-JDBC&lt;/code&gt;功能灵活且全面：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;分片策略灵活，可支持&lt;code&gt;=&lt;/code&gt;，&lt;code&gt;BETWEEN&lt;/code&gt;，&lt;code&gt;IN&lt;/code&gt;等多维度分片，也可支持多分片键共用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SQL&lt;/code&gt;解析功能完善，支持聚合，分组，排序，&lt;code&gt;Limit&lt;/code&gt;，&lt;code&gt;OR&lt;/code&gt;等查询，并且支持&lt;code&gt;Binding Table&lt;/code&gt;以及笛卡尔积的表查询。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;以下是常见的分库分表产品和&lt;code&gt;Sharding-JDBC&lt;/code&gt;的对比：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Cobar&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Cobar-client&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;TDDL&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Sharding-JDBC&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;分库&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;有&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;有&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;未开源&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;有&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;分表&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;无&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;无&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;未开源&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;有&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;中间层&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;是&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ORM支持&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;任意&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;仅MyBatis&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;任意&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;任意&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;数据库支持&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;仅MySQL&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;任意&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;任意&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;任意&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;异构语言&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;可&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;仅Java&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;仅Java&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;仅Java&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;外部依赖&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;无&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;无&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;Diamond&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;整体架构图:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;整体架构图&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;img/architecture.png&#34; alt=&#34;整体架构图1&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;quick-start:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Quick Start&lt;/h1&gt;

&lt;h2 id=&#34;引入maven依赖:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;引入maven依赖&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- 引入sharding-jdbc核心模块 --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.dangdang&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;sharding-jdbc-core&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;规则配置:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;规则配置&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Sharding-JDBC&lt;/code&gt;的分库分表通过规则配置描述，请简单浏览配置全貌：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt; ShardingRule shardingRule = new ShardingRule(
                dataSourceRule, 
                Arrays.asList(tableRule), 
                new DatabaseShardingStrategy(&amp;quot;sharding_column_1&amp;quot;, new XXXShardingAlgorithm()),
                new TableShardingStrategy(&amp;quot;sharding_column_2&amp;quot;, new XXXShardingAlgorithm()));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;规则配置包括数据源配置、表规则配置、分库策略和分表策略组成。这只是最简单的配置方式，实际使用可更加灵活，如：多分片键，分片策略直接和&lt;code&gt;tableRule&lt;/code&gt;绑定等。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;详细的规则配置请参考&lt;a href=&#34;post/user_guide&#34;&gt;用户指南&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;使用基于shardingdatasource的jdbc接口:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;使用基于ShardingDataSource的JDBC接口&lt;/h2&gt;

&lt;p&gt;通过规则配置对象获取&lt;code&gt;ShardingDataSource&lt;/code&gt;，&lt;code&gt;ShardingDataSource&lt;/code&gt;实现自&lt;code&gt;JDBC&lt;/code&gt;的标准接口&lt;code&gt;DataSource&lt;/code&gt;。然后可通过&lt;code&gt;DataSource&lt;/code&gt;选择使用原生&lt;code&gt;JDBC&lt;/code&gt;开发，或者使用&lt;code&gt;JPA&lt;/code&gt;, &lt;code&gt;MyBatis&lt;/code&gt;等&lt;code&gt;ORM&lt;/code&gt;工具。
以&lt;code&gt;JDBC&lt;/code&gt;原生实现为例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;DataSource dataSource = new ShardingDataSource(shardingRule);
String sql = &amp;quot;SELECT i.* FROM t_order o JOIN t_order_item i ON o.order_id=i.order_id WHERE o.user_id=? AND o.order_id=?&amp;quot;;
try (
        Connection conn = dataSource.getConnection();
        PreparedStatement pstmt = conn.prepareStatement(sql)) {
    pstmt.setInt(1, 10);
    pstmt.setInt(2, 1001);
    try (ResultSet rs = pstmt.executeQuery()) {
        while(rs.next()) {
            System.out.println(rs.getInt(1));
            System.out.println(rs.getInt(2));
            System.out.println(rs.getInt(3));
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>使用指南</title>
      <link>http://dangdangdotcom.github.io/sharding-jdbc/post/user_guide/</link>
      <pubDate>Fri, 08 Jan 2016 16:14:21 +0800</pubDate>
      
      <guid>http://dangdangdotcom.github.io/sharding-jdbc/post/user_guide/</guid>
      <description>

&lt;h1 id=&#34;使用指南:74c632aa9613b8dd6b95bfab1ba313e2&#34;&gt;使用指南&lt;/h1&gt;

&lt;p&gt;阅读本指南前，请先阅读快速起步。本文档使用更复杂的场景进一步介绍&lt;code&gt;Sharding-JDBC&lt;/code&gt;的分库分表能力。&lt;/p&gt;

&lt;h2 id=&#34;数据库模式:74c632aa9613b8dd6b95bfab1ba313e2&#34;&gt;数据库模式&lt;/h2&gt;

&lt;p&gt;本文档中提供了两个数据源&lt;code&gt;db0&lt;/code&gt;和&lt;code&gt;db1&lt;/code&gt;，每个数据源之中包含了两组表&lt;code&gt;t_order_0&lt;/code&gt;和&lt;code&gt;t_order_1&lt;/code&gt;，&lt;code&gt;t_order_item_0&lt;/code&gt;和&lt;code&gt;t_order_item_1&lt;/code&gt;。这两组表的建表语句为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE TABLE IF NOT EXISTS `t_order_x` (
  `order_id` INT NOT NULL,
  `user_id`  INT NOT NULL,
  PRIMARY KEY (`order_id`)
);
CREATE TABLE IF NOT EXISTS `t_order_item_x` (
  `item_id`  INT NOT NULL,
  `order_id` INT NOT NULL,
  `user_id`  INT NOT NULL,
  PRIMARY KEY (`item_id`)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;逻辑表与实际表映射关系:74c632aa9613b8dd6b95bfab1ba313e2&#34;&gt;逻辑表与实际表映射关系&lt;/h2&gt;

&lt;h3 id=&#34;均匀分布:74c632aa9613b8dd6b95bfab1ba313e2&#34;&gt;均匀分布&lt;/h3&gt;

&lt;p&gt;数据表在每个数据源内呈现均匀分布的态势&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db0
  ├── t_order_0 
  └── t_order_1 
db1
  ├── t_order_0 
  └── t_order_1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;表规则可以使用默认的配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt; TableRule orderTableRule = new TableRule(&amp;quot;t_order&amp;quot;, Arrays.asList(&amp;quot;t_order_0&amp;quot;, &amp;quot;t_order_1&amp;quot;), dataSourceRule);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;自定义分布:74c632aa9613b8dd6b95bfab1ba313e2&#34;&gt;自定义分布&lt;/h3&gt;

&lt;p&gt;数据表呈现有特定规则的分布&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db0
  ├── t_order_0 
  └── t_order_1 
db1
  ├── t_order_2
  ├── t_order_3
  └── t_order_4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;表规则可以指定每张表在数据源中的分布情况&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt; TableRule orderTableRule = new TableRule(&amp;quot;t_order&amp;quot;, Arrays.asList(&amp;quot;db0.t_order_0&amp;quot;, &amp;quot;db0.t_order_1&amp;quot;, &amp;quot;db1.t_order_2&amp;quot;, &amp;quot;db1.t_order_3&amp;quot;, &amp;quot;db1.t_order_4&amp;quot;), dataSourceRule);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;本教程采用的数据分布例子:74c632aa9613b8dd6b95bfab1ba313e2&#34;&gt;本教程采用的数据分布例子&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;db0
  ├── t_order_0               user_id为偶数   order_id为偶数
  ├── t_order_1               user_id为偶数   order_id为奇数
  ├── t_order_item_0          user_id为偶数   order_id为偶数
  └── t_order_item_1          user_id为偶数   order_id为奇数
db1
  ├── t_order_0               user_id为奇数   order_id为偶数
  ├── t_order_1               user_id为奇数   order_id为奇数
  ├── t_order_item_0          user_id为奇数   order_id为偶数
  └── t_order_item_1          user_id为奇数   order_id为奇数
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;逻辑表与实际表:74c632aa9613b8dd6b95bfab1ba313e2&#34;&gt;逻辑表与实际表&lt;/h2&gt;

&lt;p&gt;配置分库分表的目的是将原有一张表的数据分散到不同库不同表中，且不改变原有&lt;code&gt;SQL&lt;/code&gt;语句的情况下来使用这一张表。那么从一张表到多张的映射关系需要使用逻辑表与实际表这两种概念。下面通过一个例子来解释一下。假设在使用&lt;code&gt;PreparedStatement&lt;/code&gt;访问数据库，&lt;code&gt;SQL&lt;/code&gt;如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select * from t_order where user_id = ? and order_id = ?;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当&lt;code&gt;user_id=0&lt;/code&gt;且&lt;code&gt;order=0&lt;/code&gt;时，&lt;code&gt;Sharding-JDBC&lt;/code&gt;将会将&lt;code&gt;SQL&lt;/code&gt;语句转换为如下形式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select * from db0.t_order_0 where user_id = ? and order_id = ?;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中原始&lt;code&gt;SQL&lt;/code&gt;中的&lt;code&gt;t_order&lt;/code&gt;就是 &lt;strong&gt;逻辑表&lt;/strong&gt;，而转换后的&lt;code&gt;db0.t_order_0&lt;/code&gt;就是 &lt;strong&gt;实际表&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;规则配置:74c632aa9613b8dd6b95bfab1ba313e2&#34;&gt;规则配置&lt;/h2&gt;

&lt;p&gt;以上分库分表的形式&lt;code&gt;Sharding-JDBC&lt;/code&gt;是通过规则配置来进行的描述的，下面讲通过几个小节来描述规则的详细配置：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt; ShardingRule shardingRule = new ShardingRule(dataSourceRule, Arrays.asList(orderTableRule, orderItemTableRule),
                Arrays.asList(new BindingTableRule(Arrays.asList(orderTableRule, orderItemTableRule))),
                new DatabaseShardingStrategy(&amp;quot;user_id&amp;quot;, new ModuloDatabaseShardingAlgorithm()),
                new TableShardingStrategy(&amp;quot;order_id&amp;quot;, new ModuloTableShardingAlgorithm()));
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;数据源配置:74c632aa9613b8dd6b95bfab1ba313e2&#34;&gt;数据源配置&lt;/h2&gt;

&lt;p&gt;首先我们来构造&lt;code&gt;DataSourceRule&lt;/code&gt;对象，它是来描述数据源的分布规则的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt; DataSourceRule dataSourceRule = new DataSourceRule(dataSourceMap);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里构造器需要一个入参：数据源名称与真实数据源之间的映射关系，这个关系的构造方法如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Map&amp;lt;String, DataSource&amp;gt; dataSourceMap = new HashMap&amp;lt;&amp;gt;(2);
dataSourceMap.put(&amp;quot;ds_0&amp;quot;, createDataSource(&amp;quot;ds_0&amp;quot;));
dataSourceMap.put(&amp;quot;ds_1&amp;quot;, createDataSource(&amp;quot;ds_1&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;真实的数据源可以使用任意一种数据库连接池，这里使用DBCP来举例&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static DataSource createDataSource(final String dataSourceName) {
    BasicDataSource result = new BasicDataSource();
    result.setDriverClassName(com.mysql.jdbc.Driver.class.getName());
    result.setUrl(String.format(&amp;quot;jdbc:mysql://localhost:3306/%s&amp;quot;, dataSourceName));
    result.setUsername(&amp;quot;root&amp;quot;);
    result.setPassword(&amp;quot;&amp;quot;);
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;策略配置:74c632aa9613b8dd6b95bfab1ba313e2&#34;&gt;策略配置&lt;/h2&gt;

&lt;h3 id=&#34;数据源策略与表策略:74c632aa9613b8dd6b95bfab1ba313e2&#34;&gt;数据源策略与表策略&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;../../img/StrategyClass.900.png&#34; alt=&#34;策略类图&#34; /&gt;
Sharding-JDBC认为对于分片策略存有两种维度
- 数据源分片策略&lt;code&gt;DatabaseShardingStrategy&lt;/code&gt;：数据被分配的目标数据源
- 表分片策略&lt;code&gt;TableShardingStrategy&lt;/code&gt;：数据被分配的目标表，该目标表存在与该数据的目标数据源内。故表分片策略是依赖与数据源分片策略的结果的
这里注意的是两种策略的API完全相同，以下针对策略API的讲解将适用于这两种策略&lt;/p&gt;

&lt;h3 id=&#34;全局默认策略与特定表策略:74c632aa9613b8dd6b95bfab1ba313e2&#34;&gt;全局默认策略与特定表策略&lt;/h3&gt;

&lt;p&gt;策略是作用在特定的表规则上的，数据源策略与表策略与特定表相关&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;TableRule orderTableRule = new TableRule(&amp;quot;t_order&amp;quot;, Arrays.asList(&amp;quot;t_order_0&amp;quot;, &amp;quot;t_order_1&amp;quot;),
                  new DatabaseShardingStrategy(&amp;quot;user_id&amp;quot;, new ModuloDatabaseShardingAlgorithm()),
                  new TableShardingStrategy(&amp;quot;order_id&amp;quot;, new ModuloTableShardingAlgorithm()),
                  dataSourceRule);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果分片规则中的所有表或大部分表的分片策略相同，可以使用默认策略来简化配置。一下两种配置是等价的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  //使用了默认策略配置
  TableRule orderTableRule = new TableRule(&amp;quot;t_order&amp;quot;, Arrays.asList(&amp;quot;t_order_0&amp;quot;, &amp;quot;t_order_1&amp;quot;), dataSourceRule);
  TableRule orderItemTableRule = new TableRule(&amp;quot;t_order_item&amp;quot;, Arrays.asList(&amp;quot;t_order_item_0&amp;quot;, &amp;quot;t_order_item_1&amp;quot;), dataSourceRule);
  ShardingRule shardingRule = new ShardingRule(dataSourceRule, Arrays.asList(orderTableRule, orderItemTableRule),
                Arrays.asList(new BindingTableRule(Arrays.asList(orderTableRule, orderItemTableRule))),
                new DatabaseShardingStrategy(&amp;quot;user_id&amp;quot;, new ModuloDatabaseShardingAlgorithm()),
                new TableShardingStrategy(&amp;quot;order_id&amp;quot;, new ModuloTableShardingAlgorithm()));
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  //未使用默认策略配置
  TableRule orderTableRule = new TableRule(&amp;quot;t_order&amp;quot;, Arrays.asList(&amp;quot;t_order_0&amp;quot;, &amp;quot;t_order_1&amp;quot;), dataSourceRule,
          new DatabaseShardingStrategy(&amp;quot;user_id&amp;quot;, new ModuloDatabaseShardingAlgorithm()),
          new TableShardingStrategy(&amp;quot;order_id&amp;quot;, new ModuloTableShardingAlgorithm()));
  TableRule orderItemTableRule = new TableRule(&amp;quot;t_order_item&amp;quot;, Arrays.asList(&amp;quot;t_order_item_0&amp;quot;, &amp;quot;t_order_item_1&amp;quot;), dataSourceRule,
          new DatabaseShardingStrategy(&amp;quot;user_id&amp;quot;, new ModuloDatabaseShardingAlgorithm()),
          new TableShardingStrategy(&amp;quot;order_id&amp;quot;, new ModuloTableShardingAlgorithm()));
  ShardingRule shardingRule = new ShardingRule(dataSourceRule, Arrays.asList(orderTableRule, orderItemTableRule),
          Arrays.asList(new BindingTableRule(Arrays.asList(orderTableRule, orderItemTableRule))));
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;分片键:74c632aa9613b8dd6b95bfab1ba313e2&#34;&gt;分片键&lt;/h3&gt;

&lt;p&gt;分片键是分片策略的第一个参数。分片键表示的是SQL语句中WHERE中的条件列。分片键可以配置多个&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;单分片策略&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;new TableShardingStrategy(&amp;quot;order_id&amp;quot;, new SingleKeyShardingAlgorithm()))
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;多分片策略&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;new TableShardingStrategy(Arrays.asList(&amp;quot;order_id&amp;quot;，&amp;quot;order_type&amp;quot;, &amp;quot;order_date&amp;quot;), new MultiKeyShardingAlgorithm()))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;分片算法:74c632aa9613b8dd6b95bfab1ba313e2&#34;&gt;分片算法&lt;/h3&gt;

&lt;p&gt;分片算法接口类图关系如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../img/AlgorithmClass.900.png&#34; alt=&#34;算法&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;绑定表:74c632aa9613b8dd6b95bfab1ba313e2&#34;&gt;绑定表&lt;/h3&gt;

&lt;p&gt;绑定表代表一组表，这组表的逻辑表与实际表之间的映射关系是相同的。比如&lt;code&gt;t_order&lt;/code&gt;与&lt;code&gt;t_order_item&lt;/code&gt;就是这样一组绑定表关系,它们的分库与分表策略是完全相同的,那么可以使用它们的表规则将它们配置成绑定表&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;new BindingTableRule(Arrays.asList(orderTableRule, orderItemTableRule))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么在进行SQL路由时，如果SQL为&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT i.* FROM t_order o JOIN t_order_item i ON o.order_id=i.order_id WHERE o.user_id=? AND o.order_id=?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;t_order&lt;/code&gt;在FROM的最左侧，Sharding-JDBC将会以它作为整个绑定表的主表。所有路由计算将会只使用主表的策略，那么&lt;code&gt;t_order_item&lt;/code&gt;表的分片计算将会使用&lt;code&gt;t_order&lt;/code&gt;的条件。故绑定表之间的分区键要完全相同。&lt;/p&gt;

&lt;h2 id=&#34;分片算法详解:74c632aa9613b8dd6b95bfab1ba313e2&#34;&gt;分片算法详解&lt;/h2&gt;

&lt;h3 id=&#34;单分片键算法与多分片键算法:74c632aa9613b8dd6b95bfab1ba313e2&#34;&gt;单分片键算法与多分片键算法&lt;/h3&gt;

&lt;p&gt;这两种算法从名字上就可以知道前者是针对只有一个分片键，后者是针对有多个分片键的。单分片键算法是多分片键算法的一种简便形式，所以完全可以使用多分片算法去替代单分片键算法。下面两种形式是等价的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;new TableShardingStrategy(&amp;quot;order_id&amp;quot;, new SingleKeyShardingAlgorithm()))
new TableShardingStrategy(Arrays.asList(&amp;quot;order_id&amp;quot;), new MultiKeyShardingAlgorithm()))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同时在算法内部，&lt;code&gt;doSharding&lt;/code&gt;等方法的&lt;code&gt;shardingValue&lt;/code&gt;入参根据使用算法类型不同而不同
单分片键算法，方法签名&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public String doEqualSharding(final Collection&amp;lt;String&amp;gt; dataSourceNames, final ShardingValue&amp;lt;Integer&amp;gt; shardingValue) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;多分片键算法，方法签名&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Collection&amp;lt;String&amp;gt; doSharding(final Collection&amp;lt;String&amp;gt; availableTargetNames, final Collection&amp;lt;ShardingValue&amp;lt;?&amp;gt;&amp;gt; shardingValues)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;分片键算法类型:74c632aa9613b8dd6b95bfab1ba313e2&#34;&gt;分片键算法类型&lt;/h3&gt;

&lt;p&gt;根据数据源策略与表策略、单分片与多分片，这两种组合，一共产生了4种可供实现的分片算法的接口&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;单分片键数据源分片算法&lt;code&gt;SingleKeyDatabaseShardingAlgorithm&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;单分片表分片算法&lt;code&gt;SingleKeyTableShardingAlgorithm&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;多分片键数据源分片算法&lt;code&gt;MultipleKeyDatabaseShardingAlgorithm&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;多分片表分片算法&lt;code&gt;MultipleKeyTableShardingAlgorithm&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;单分片键算法:74c632aa9613b8dd6b95bfab1ba313e2&#34;&gt;单分片键算法&lt;/h3&gt;

&lt;p&gt;单分片键算法需要实现三个方法，下面以”单分片键数据源分片算法“举例&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public String doEqualSharding(final Collection&amp;lt;String&amp;gt; availableTargetNames, final ShardingValue&amp;lt;Integer&amp;gt; shardingValue)

@Override
public Collection&amp;lt;String&amp;gt; doInSharding(final Collection&amp;lt;String&amp;gt; availableTargetNames, final ShardingValue&amp;lt;Integer&amp;gt; shardingValue)

@Override
public Collection&amp;lt;String&amp;gt; doBetweenSharding(final Collection&amp;lt;String&amp;gt; availableTargetNames, final ShardingValue&amp;lt;Integer&amp;gt; shardingValue)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这三种算法作用如下
- &lt;code&gt;doEqualSharding&lt;/code&gt;在WHERE使用&lt;code&gt;=&lt;/code&gt;作为条件分片键。算法中使用&lt;code&gt;shardingValue.getValue()&lt;/code&gt;获取等&lt;code&gt;=&lt;/code&gt;后的值
- &lt;code&gt;doInSharding&lt;/code&gt;在WHERE使用&lt;code&gt;IN&lt;/code&gt;作为条件分片键。算法中使用&lt;code&gt;shardingValue.getValues()&lt;/code&gt;获取&lt;code&gt;IN&lt;/code&gt;后的值
- &lt;code&gt;doBetweenSharding&lt;/code&gt;在WHERE使用&lt;code&gt;BETWEEN&lt;/code&gt;作为条件分片键。算法中使用&lt;code&gt;shardingValue.getValueRange()&lt;/code&gt;获取&lt;code&gt;BETWEEN&lt;/code&gt;后的值&lt;/p&gt;

&lt;p&gt;下面是一个余2的算法的例子，当分片键的值除以2余数就是实际表的结尾。注意注释中提供了一些算法生成SQL的结果，参数&lt;code&gt;tableNames&lt;/code&gt;集合中有两个参数&lt;code&gt;t_order_0&lt;/code&gt;和&lt;code&gt;t_order_1&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt; public final class ModuloDatabaseShardingAlgorithm implements SingleKeyDatabaseShardingAlgorithm&amp;lt;Integer&amp;gt; {
    
    /**
    *  select * from t_order from t_order where order_id = 11 
    *          └── SELECT *  FROM t_order_1 WHERE order_id = 11
    *  select * from t_order from t_order where order_id = 44
    *          └── SELECT *  FROM t_order_0 WHERE order_id = 44
    */
    public String doEqualSharding(final Collection&amp;lt;String&amp;gt; tableNames, final ShardingValue&amp;lt;Integer&amp;gt; shardingValue) {
        for (String each : tableNames) {
            if (each.endsWith(shardingValue.getValue() % 2 + &amp;quot;&amp;quot;)) {
                return each;
            }
        }
        throw new IllegalArgumentException();
    }
    
    /**
    *  select * from t_order from t_order where order_id in (11,44)  
    *          ├── SELECT *  FROM t_order_0 WHERE order_id IN (11,44) 
    *          └── SELECT *  FROM t_order_1 WHERE order_id IN (11,44) 
    *  select * from t_order from t_order where order_id in (11,13,15)  
    *          └── SELECT *  FROM t_order_1 WHERE order_id IN (11,13,15)  
    *  select * from t_order from t_order where order_id in (22,24,26)  
    *          └──SELECT *  FROM t_order_0 WHERE order_id IN (22,24,26) 
    */
    public Collection&amp;lt;String&amp;gt; doInSharding(final Collection&amp;lt;String&amp;gt; tableNames, final ShardingValue&amp;lt;Integer&amp;gt; shardingValue) {
        Collection&amp;lt;String&amp;gt; result = new LinkedHashSet&amp;lt;&amp;gt;(tableNames.size());
        for (Integer value : shardingValue.getValues()) {
            for (String dataSourceName : tableNames) {
                if (dataSourceName.endsWith(value % 2 + &amp;quot;&amp;quot;)) {
                    result.add(dataSourceName);
                }
            }
        }
        return result;
    }
    
    /**
    *  select * from t_order from t_order where order_id between 10 and 20 
    *          ├── SELECT *  FROM t_order_0 WHERE order_id BETWEEN 10 AND 20 
    *          └── SELECT *  FROM t_order_1 WHERE order_id BETWEEN 10 AND 20 
    */
    public Collection&amp;lt;String&amp;gt; doBetweenSharding(final Collection&amp;lt;String&amp;gt; tableNames, final ShardingValue&amp;lt;Integer&amp;gt; shardingValue) {
        Collection&amp;lt;String&amp;gt; result = new LinkedHashSet&amp;lt;&amp;gt;(tableNames.size());
        Range&amp;lt;Integer&amp;gt; range = (Range&amp;lt;Integer&amp;gt;) shardingValue.getValueRange();
        for (Integer i = range.lowerEndpoint(); i &amp;lt;= range.upperEndpoint(); i++) {
            for (String each : tableNames) {
                if (each.endsWith(i % 2 + &amp;quot;&amp;quot;)) {
                    result.add(each);
                }
            }
        }
        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;多分片键算法:74c632aa9613b8dd6b95bfab1ba313e2&#34;&gt;多分片键算法&lt;/h3&gt;

&lt;p&gt;多分片键试用于使用场景比较复杂，为了能提供更高的灵活性，故只提供实现一个方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public Collection&amp;lt;String&amp;gt; doSharding(final Collection&amp;lt;String&amp;gt; availableTargetNames, final Collection&amp;lt;ShardingValue&amp;lt;?&amp;gt;&amp;gt; shardingValues)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;算法实现的时候根据&lt;code&gt;shardingValue.getType()&lt;/code&gt;来获取条件是&lt;code&gt;=&lt;/code&gt;，&lt;code&gt;IN&lt;/code&gt;或者&lt;code&gt;BETWEEN&lt;/code&gt;。然后根据业务进行灵活的实现。&lt;/p&gt;

&lt;p&gt;如果表的数据分布如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db0
  ├── t_order_00               user_id以a偶数   order_id为偶数
  ├── t_order_01               user_id以a偶数   order_id为奇数
  ├── t_order_10               user_id以b奇数   order_id为偶数
  └── t_order_11               user_id以b奇数   order_id为奇数

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;算法实现如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class MultipleKeysModuloTableShardingAlgorithm implements MultipleKeysTableShardingAlgorithm {
    
    @Override
    public Collection&amp;lt;String&amp;gt; doSharding(final Collection&amp;lt;String&amp;gt; availableTargetNames, final Collection&amp;lt;ShardingValue&amp;lt;?&amp;gt;&amp;gt; shardingValues) {
        Set&amp;lt;Integer&amp;gt; orderIdValueSet = getShardingValue(shardingValues, &amp;quot;order_id&amp;quot;);
        Set&amp;lt;Integer&amp;gt; userIdValueSet = getShardingValue(shardingValues, &amp;quot;user_id&amp;quot;);
    
        List&amp;lt;String&amp;gt; result = new ArrayList&amp;lt;&amp;gt;();
        /*
        userIdValueSet[10,11] + orderIdValueSet[101,102] =&amp;gt; valueResult[[10,101],[10,102],[11,101],[11,102]]
         */
        Set&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; valueResult = Sets.cartesianProduct(userIdValueSet, orderIdValueSet);
        for (List&amp;lt;Integer&amp;gt; value : valueResult) {
            String suffix = Joiner.on(&amp;quot;&amp;quot;).join(value.get(0) % 2, value.get(1) % 2);
            for (String tableName : availableTargetNames) {
                if (tableName.endsWith(suffix)) {
                    result.add(tableName);
                }
            }
        
        }
        return result;
    }
    
    private Set&amp;lt;Integer&amp;gt; getShardingValue(final Collection&amp;lt;ShardingValue&amp;lt;?&amp;gt;&amp;gt; shardingValues, final String shardingKey) {
        Set&amp;lt;Integer&amp;gt; valueSet = new HashSet&amp;lt;&amp;gt;();
        ShardingValue&amp;lt;Integer&amp;gt; shardingValue = null;
        for (ShardingValue&amp;lt;?&amp;gt; each : shardingValues) {
            if (each.getColumnName().equals(shardingKey)) {
                shardingValue = (ShardingValue&amp;lt;Integer&amp;gt;) each;
                break;
            }
        }
        if (null == shardingValue) {
            return valueSet;
        }
        switch (shardingValue.getType()) {
            case SINGLE:
                valueSet.add(shardingValue.getValue());
                break;
            case LIST:
                valueSet.addAll(shardingValue.getValues());
                break;
            case RANGE:
                for (Integer i = shardingValue.getValueRange().lowerEndpoint(); i &amp;lt;= shardingValue.getValueRange().upperEndpoint(); i++) {
                    valueSet.add(i);
                }
                break;
            default:
                throw new UnsupportedOperationException();
        }
        return valueSet;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;构造shardingdatasource:74c632aa9613b8dd6b95bfab1ba313e2&#34;&gt;构造ShardingDataSource&lt;/h2&gt;

&lt;p&gt;完成规则配置后，我们就可以得到&lt;code&gt;ShardingDataSource&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;new ShardingDataSource(shardingRule);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;使用shardingdatasource:74c632aa9613b8dd6b95bfab1ba313e2&#34;&gt;使用ShardingDataSource&lt;/h2&gt;

&lt;p&gt;通过一个例子来看看如何使用该数据源&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String sql = &amp;quot;SELECT i.* FROM t_order o JOIN t_order_item i ON o.order_id=i.order_id WHERE o.user_id=? AND o.order_id=?&amp;quot;;
        try (
                Connection conn = dataSource.getConnection();
                PreparedStatement pstmt = conn.prepareStatement(sql);
                ) {
            pstmt.setInt(1, 10);
            pstmt.setInt(2, 1001);
            ResultSet rs = pstmt.executeQuery();
            while (rs.next()) {
                System.out.println(rs.getInt(1));
                System.out.println(rs.getInt(2));
                System.out.println(rs.getInt(3));
            }
            rs.close();
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该数据源与普通数据源完全相同，你可以通过上例的API形式来使用，也可以将其配置在Spring，Hibernate等框架中使用。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>详细功能列表</title>
      <link>http://dangdangdotcom.github.io/sharding-jdbc/post/features/</link>
      <pubDate>Fri, 08 Jan 2016 16:14:21 +0800</pubDate>
      
      <guid>http://dangdangdotcom.github.io/sharding-jdbc/post/features/</guid>
      <description>

&lt;h1 id=&#34;详细功能列表:e1ec7fcfd5aa4d3ea3e990d9b707a3b4&#34;&gt;详细功能列表&lt;/h1&gt;

&lt;h2 id=&#34;功能性需求:e1ec7fcfd5aa4d3ea3e990d9b707a3b4&#34;&gt;功能性需求&lt;/h2&gt;

&lt;h3 id=&#34;分库分表-同时支持分库和分表:e1ec7fcfd5aa4d3ea3e990d9b707a3b4&#34;&gt;分库分表：同时支持分库和分表&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;分片规则自由定制&lt;/li&gt;
&lt;li&gt;支持多分片键&lt;/li&gt;
&lt;li&gt;支持通过&lt;code&gt;=&lt;/code&gt;，&lt;code&gt;BETWEEN&lt;/code&gt;，&lt;code&gt;IN&lt;/code&gt;分片&lt;/li&gt;
&lt;li&gt;支持&lt;code&gt;Binding Table&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;支持多表笛卡尔积查询&lt;/li&gt;
&lt;li&gt;支持多表结果归并&lt;/li&gt;
&lt;li&gt;支持聚合查询结果归并&lt;/li&gt;
&lt;li&gt;支持&lt;code&gt;AVG&lt;/code&gt;函数改写为&lt;code&gt;SUM/COUNT&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;支持&lt;code&gt;Order By&lt;/code&gt;结果归并&lt;/li&gt;
&lt;li&gt;支持&lt;code&gt;Group By&lt;/code&gt;结果归并&lt;/li&gt;
&lt;li&gt;支持&lt;code&gt;LIMIT&lt;/code&gt;分页查询以及多库表结果改写及归并&lt;/li&gt;
&lt;li&gt;支持&lt;code&gt;OR&lt;/code&gt;查询&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;易用性:e1ec7fcfd5aa4d3ea3e990d9b707a3b4&#34;&gt;易用性&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;JDBC&lt;/code&gt;协议适配&lt;/p&gt;

&lt;p&gt;1.1. 全&lt;code&gt;ORM&lt;/code&gt;支持&lt;/p&gt;

&lt;p&gt;1.2. 全数据库连接池支持&lt;/p&gt;

&lt;p&gt;1.3. 多数据库支持(目前仅&lt;code&gt;MySQL&lt;/code&gt;，未来计划支持&lt;code&gt;Oracle&lt;/code&gt;，&lt;code&gt;SQLServer&lt;/code&gt;和&lt;code&gt;DB2&lt;/code&gt;)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Spring&lt;/code&gt;命名空间支持（待开源）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;基于动态语言的分片策略配置（待开源）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Metrics&lt;/code&gt;统计监控&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;性能:e1ec7fcfd5aa4d3ea3e990d9b707a3b4&#34;&gt;性能&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;基于&lt;code&gt;Druid&lt;/code&gt;的高性能&lt;code&gt;SQL&lt;/code&gt;解析&lt;/li&gt;
&lt;li&gt;多线程处理结果归并&lt;/li&gt;
&lt;li&gt;性能损失率不足&lt;code&gt;10%&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;稳定性:e1ec7fcfd5aa4d3ea3e990d9b707a3b4&#34;&gt;稳定性&lt;/h2&gt;

&lt;p&gt;完善的疲劳测试，普通查询无&lt;code&gt;Full GC&lt;/code&gt;（&lt;code&gt;Group By&lt;/code&gt;除外）&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>架构图</title>
      <link>http://dangdangdotcom.github.io/sharding-jdbc/post/architecture/</link>
      <pubDate>Fri, 08 Jan 2016 16:14:21 +0800</pubDate>
      
      <guid>http://dangdangdotcom.github.io/sharding-jdbc/post/architecture/</guid>
      <description>

&lt;h1 id=&#34;架构图:1bf455b3a3c6e1e40be41ef6023b75eb&#34;&gt;架构图&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;../../img/architecture.png&#34; alt=&#34;整体架构图1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../img/parse.png&#34; alt=&#34;SQL解析&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../img/route.png&#34; alt=&#34;SQL路由&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../img/execute.png&#34; alt=&#34;SQL执行&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../img/merge.png&#34; alt=&#34;结果归并&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用限制</title>
      <link>http://dangdangdotcom.github.io/sharding-jdbc/post/restriction/</link>
      <pubDate>Fri, 08 Jan 2016 16:14:21 +0800</pubDate>
      
      <guid>http://dangdangdotcom.github.io/sharding-jdbc/post/restriction/</guid>
      <description>

&lt;h1 id=&#34;使用限制:e136e3f58c4f85ea1188986eb33d0381&#34;&gt;使用限制&lt;/h1&gt;

&lt;h2 id=&#34;jdbc-未支持列表:e136e3f58c4f85ea1188986eb33d0381&#34;&gt;&lt;code&gt;JDBC&lt;/code&gt;未支持列表&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Sharding-JDBC&lt;/code&gt;暂时未支持不常用的&lt;code&gt;JDBC&lt;/code&gt;方法。&lt;/p&gt;

&lt;h3 id=&#34;datasource-接口:e136e3f58c4f85ea1188986eb33d0381&#34;&gt;&lt;code&gt;DataSource&lt;/code&gt;接口&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;不支持&lt;code&gt;timeout&lt;/code&gt;相关操作&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;connection-接口:e136e3f58c4f85ea1188986eb33d0381&#34;&gt;&lt;code&gt;Connection&lt;/code&gt;接口&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;不支持存储过程，函数，游标的操作&lt;/li&gt;
&lt;li&gt;不支持执行&lt;code&gt;native&lt;/code&gt;的&lt;code&gt;SQL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;不支持&lt;code&gt;savepoint&lt;/code&gt;相关操作&lt;/li&gt;
&lt;li&gt;不支持&lt;code&gt;Schema/Catalog&lt;/code&gt;的操作&lt;/li&gt;
&lt;li&gt;不支持自定义类型映射&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;statement-和-preparedstatement-接口:e136e3f58c4f85ea1188986eb33d0381&#34;&gt;&lt;code&gt;Statement&lt;/code&gt;和&lt;code&gt;PreparedStatement&lt;/code&gt;接口&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;不支返回多个结果集的语句&lt;/li&gt;
&lt;li&gt;不支持国际化字符的操作&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;对于-resultset-接口:e136e3f58c4f85ea1188986eb33d0381&#34;&gt;对于&lt;code&gt;ResultSet&lt;/code&gt;接口&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;不支持对于结果集指针位置判断&lt;/li&gt;
&lt;li&gt;不支持通过非next方法改变结果指针位置&lt;/li&gt;
&lt;li&gt;不支持修改结果集内容&lt;/li&gt;
&lt;li&gt;不支持获取国际化字符&lt;/li&gt;
&lt;li&gt;不支持获取&lt;code&gt;Array&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;jdbc-4-1:e136e3f58c4f85ea1188986eb33d0381&#34;&gt;JDBC 4.1&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;不支持JDBC 4.1接口新功能&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;查询所有未支持方法，请阅读&lt;code&gt;com.dangdang.ddframe.rdb.sharding.jdbc.unsupported&lt;/code&gt;包。&lt;/p&gt;

&lt;h2 id=&#34;sql语句限制:e136e3f58c4f85ea1188986eb33d0381&#34;&gt;SQL语句限制&lt;/h2&gt;

&lt;h3 id=&#34;不支持ddl语句:e136e3f58c4f85ea1188986eb33d0381&#34;&gt;不支持DDL语句&lt;/h3&gt;

&lt;h3 id=&#34;不支持子语句:e136e3f58c4f85ea1188986eb33d0381&#34;&gt;不支持子语句&lt;/h3&gt;

&lt;h3 id=&#34;不支持-union-和-union-all:e136e3f58c4f85ea1188986eb33d0381&#34;&gt;不支持&lt;code&gt;UNION&lt;/code&gt; 和 &lt;code&gt;UNION ALL&lt;/code&gt;&lt;/h3&gt;

&lt;h3 id=&#34;不支持特殊-insert:e136e3f58c4f85ea1188986eb33d0381&#34;&gt;不支持特殊&lt;code&gt;INSERT&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;每条&lt;code&gt;INSERT&lt;/code&gt;语句只能插入一条数据，不支持&lt;code&gt;VALUES&lt;/code&gt;后有多行数据的语句&lt;/p&gt;

&lt;h3 id=&#34;不支持-distinct-聚合:e136e3f58c4f85ea1188986eb33d0381&#34;&gt;不支持&lt;code&gt;DISTINCT&lt;/code&gt;聚合&lt;/h3&gt;

&lt;h3 id=&#34;对于-谨慎使用:e136e3f58c4f85ea1188986eb33d0381&#34;&gt;对于&lt;code&gt;*&lt;/code&gt;谨慎使用&lt;/h3&gt;

&lt;p&gt;一般情况下&lt;code&gt;SELECT&lt;/code&gt;语句中是可以使用&lt;code&gt;*&lt;/code&gt;的，如下的&lt;code&gt;SQL&lt;/code&gt;可以正常在&lt;code&gt;Sharding-JDBC&lt;/code&gt;中使用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select * from order;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但以下几种SQL不允许使用&lt;code&gt;*&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;语句中存在聚合函数&lt;code&gt;AVG&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GROUP BY&lt;/code&gt;语句&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ORDER BY&lt;/code&gt;语句&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>压力测试报告</title>
      <link>http://dangdangdotcom.github.io/sharding-jdbc/post/stress_test/</link>
      <pubDate>Fri, 08 Jan 2016 16:14:21 +0800</pubDate>
      
      <guid>http://dangdangdotcom.github.io/sharding-jdbc/post/stress_test/</guid>
      <description>

&lt;h1 id=&#34;压力测试报告:da68abc810593941936aaba3d62b3b96&#34;&gt;压力测试报告&lt;/h1&gt;

&lt;h2 id=&#34;测试目的:da68abc810593941936aaba3d62b3b96&#34;&gt;测试目的&lt;/h2&gt;

&lt;p&gt;对&lt;code&gt;Sharding-JDBC&lt;/code&gt;进行性能测试，客观、公正评估系统的性能，目的有三:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;对比&lt;code&gt;Sharding-JDBC&lt;/code&gt;和&lt;code&gt;JDBC&lt;/code&gt;的性能。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Sharding-JDBC&lt;/code&gt;是否通过扩展数据库解决&lt;code&gt;JDBC&lt;/code&gt;吞吐量不足的问题。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Sharding-JDBC&lt;/code&gt;的稳定性。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;测试数据库配置:da68abc810593941936aaba3d62b3b96&#34;&gt;测试数据库配置&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;数据库实例&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;DB1&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;DB2&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;操作系统&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;centOS5.4&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;centOS5.4&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;CPU&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2C四核&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2C四核&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;内存&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32GB&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32GB&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;硬盘&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;250G*2_RAID1+600G*4_RAID10&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;250G*2_RAID1+600G*4_RAID10&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Mysql版本&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;5.5.19&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;5.5.19&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;数据表字段数量&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;70&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;70&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;数据表行数&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1000万&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1000万&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;网络拓扑:da68abc810593941936aaba3d62b3b96&#34;&gt;网络拓扑&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;img/stress_test_arch.png&#34; alt=&#34;网络拓扑图&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;单库情况下sharding-jdbc与jdbc性能对比:da68abc810593941936aaba3d62b3b96&#34;&gt;单库情况下Sharding-JDBC与JDBC性能对比&lt;/h2&gt;

&lt;p&gt;测试结论：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;查询操作，Sharding-JDBC的TPS为JDBC的TPS的99.8%&lt;/li&gt;
&lt;li&gt;插入操作，Sharding-JDBC的TPS为JDBC的TPS的90.2%&lt;/li&gt;
&lt;li&gt;更新操作，Sharding-JDBC的TPS为JDBC的TPS的93.1%&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;查询:da68abc810593941936aaba3d62b3b96&#34;&gt;查询&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;横坐标：并发用户数&lt;/li&gt;
&lt;li&gt;纵坐标：TPS&lt;/li&gt;
&lt;/ul&gt;

&lt;canvas id=&#34;compareQuery&#34; width=&#34;400&#34; height=&#34;150&#34;&gt;&lt;/canvas&gt;

&lt;h3 id=&#34;插入:da68abc810593941936aaba3d62b3b96&#34;&gt;插入&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;横坐标：并发用户数&lt;/li&gt;
&lt;li&gt;纵坐标：TPS&lt;/li&gt;
&lt;/ul&gt;

&lt;canvas id=&#34;compareInsert&#34; width=&#34;400&#34; height=&#34;150&#34;&gt;&lt;/canvas&gt;

&lt;h3 id=&#34;更新:da68abc810593941936aaba3d62b3b96&#34;&gt;更新&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;横坐标：并发用户数&lt;/li&gt;
&lt;li&gt;纵坐标：TPS&lt;/li&gt;
&lt;/ul&gt;

&lt;canvas id=&#34;compareUpdate&#34; width=&#34;400&#34; height=&#34;150&#34;&gt;&lt;/canvas&gt;

&lt;h2 id=&#34;sharding-jdbc单库与双库性能对比:da68abc810593941936aaba3d62b3b96&#34;&gt;Sharding-JDBC单库与双库性能对比&lt;/h2&gt;

&lt;p&gt;对比测试：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;单库用例中所有数据全部在DB1中&lt;/li&gt;
&lt;li&gt;双库用例中所有数据均匀分布在DB1与DB2中&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;结论：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;查询操作，TPS双库比单库可以增加大约94%的性能&lt;/li&gt;
&lt;li&gt;插入操作，TPS双库比单库可以增加大约60%的性能&lt;/li&gt;
&lt;li&gt;更新操作，TPS双库比单库可以增加大约89%的性能&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;查询-1:da68abc810593941936aaba3d62b3b96&#34;&gt;查询&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;横坐标：并发用户数&lt;/li&gt;
&lt;li&gt;纵坐标：TPS&lt;/li&gt;
&lt;/ul&gt;

&lt;canvas id=&#34;singleAndDubbleQuery&#34; width=&#34;400&#34; height=&#34;150&#34;&gt;&lt;/canvas&gt;

&lt;h3 id=&#34;插入-1:da68abc810593941936aaba3d62b3b96&#34;&gt;插入&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;横坐标：并发用户数&lt;/li&gt;
&lt;li&gt;纵坐标：TPS&lt;/li&gt;
&lt;/ul&gt;

&lt;canvas id=&#34;singleAndDubbleInsert&#34; width=&#34;400&#34; height=&#34;150&#34;&gt;&lt;/canvas&gt;

&lt;h3 id=&#34;更新-1:da68abc810593941936aaba3d62b3b96&#34;&gt;更新&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;横坐标：并发用户数&lt;/li&gt;
&lt;li&gt;纵坐标：TPS&lt;/li&gt;
&lt;/ul&gt;

&lt;canvas id=&#34;singleAndDubbleUpdate&#34; width=&#34;400&#34; height=&#34;150&#34;&gt;&lt;/canvas&gt;

&lt;h2 id=&#34;sharding-jdbc疲劳测试:da68abc810593941936aaba3d62b3b96&#34;&gt;Sharding-JDBC疲劳测试&lt;/h2&gt;

&lt;p&gt;经过8个小时的疲劳测试，jvm的堆大约占用不到600MB的内存，且使用量比较稳定。没有发生fullgc。
&lt;canvas id=&#34;fatigueTest&#34; width=&#34;400&#34; height=&#34;150&#34;&gt;&lt;/canvas&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>未来线路规划</title>
      <link>http://dangdangdotcom.github.io/sharding-jdbc/post/roadmap/</link>
      <pubDate>Fri, 08 Jan 2016 16:14:21 +0800</pubDate>
      
      <guid>http://dangdangdotcom.github.io/sharding-jdbc/post/roadmap/</guid>
      <description>

&lt;h1 id=&#34;未来线路规划:cd4a1b36ed2b93cfc52abf77a7d25d03&#34;&gt;未来线路规划&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;读写分离&lt;/li&gt;
&lt;li&gt;柔性分布式事务&lt;/li&gt;
&lt;li&gt;分布式主键生成策略&lt;/li&gt;
&lt;li&gt;SQL重写优化，进一步提升性能&lt;/li&gt;
&lt;li&gt;SQL Hint，可指定某SQL在某具体库表执行，基于业务规则而非SQL解析路由&lt;/li&gt;
&lt;li&gt;小表广播&lt;/li&gt;
&lt;li&gt;HA相关&lt;/li&gt;
&lt;li&gt;流量控制&lt;/li&gt;
&lt;li&gt;数据库建表工具&lt;/li&gt;
&lt;li&gt;数据迁移&lt;/li&gt;
&lt;li&gt;复杂SQL解析支持，如子查询，存储过程等&lt;/li&gt;
&lt;li&gt;Oracle， SQLServer，DB2支持&lt;/li&gt;
&lt;li&gt;配置中心&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>